# Random Spanning Tree Sampler in C

## Build Instructions
``` bash
mkdir build && cd build
cmake ..
make
```
## Dependencies
- igraph: a C library for creating, manipulating and analysing graphs 
  - [GitHub](https://github.com/igraph/igraph)
  - [Installation Guide](https://igraph.org/c/)
- CMake and other build tools

## Currently Implemented Graphs
- Small graph generated by specifing edges
- Random connnected graph, for a given number of vertices, density target, maximum and minimum degree
- Full graph, Cycle graph, Lattice graph
- Many other graphs that are included in the igraph library [Graph Generators](https://igraph.org/c/doc/igraph-Generators.html)

## Running Time of The Approximate Counter

### 2020-04-25 Update

I have done the following major improvement
- Remove igraph dependency for heavy calculation part. Rewrite a small `GraphLite` class to handle the undirected graph better, more efficient
  - Stored as edge list and incident list of vertices
  - No hashing, linear storage; all operation used in the random walk could be done in O(1) vector entry access
  - When edge and vertex are removed, they are not physically deleted, so the index will not be messed up; instead they are properly labelled as deleted
  - Contracted edges make connecting vertices behaving as one, by reassigning edges. Previous attempt to keep the contracted vertices does not work well, as more time are wasted random walking on those existing edges
- igraph is still used for graph generation purpose
- Implemented Wilson's algorithm exactly, in the hope to help uniformity
- Fixed ratio estimating issue, when the edge we want to estimated is already contracted away (no longer exists). In this case, the ratio contributing is simply unity 1
- Enabled predefined edges shuffling to make progress of ratio estimation more even
  - TODO: change predefine edges when need, e.g. when non-estimated edges are being contracted, we can get their ratios for free!

### 200 Vertices, 0.1 Density, No Maximum Degree Limit
```
Sat Apr 25 20:39:29 2020
Created graph with 200 vertices and 19900 edges
3808316 samples taken, with per sample time taking 0.022 ms
Total time spent 84 seconds

FINAL result = inf with 47415646 effective samples
```
---

_Old Attempt Below..._

### 50 Vertices, Full Graph
```
Fri Apr 24 11:41:14 2020
Created graph with 50 vertices and 1225 edges
454403 samples taken, with per sample time taking 0.01 ms
Total time spent 6 seconds

FINAL result = 3.0410e+81 with 2541313 effective samples
```
### 100 Vertices, Full Graph
```
Fri Apr 24 11:26:45 2020
Created graph with 100 vertices and 4950 edges
1266882 samples taken, with per sample time taking 0.04 ms
Total time spent 53 seconds

FINAL result = 5.8982e+195 with 10333308 effective samples
```

### 200 Vertices, Full Graph
```
Fri Apr 24 11:42:09 2020
Created graph with 200 vertices and 19900 edges
3672212 samples taken, with per sample time taking 0.11 ms
Total time spent 414 seconds

FINAL result = inf with 41766822 effective samples
```
## Examples of Running Time of the Sampler

### 100 Vertices, 0.1 Density, No Maximum Degree Limit
```
Created graph with 100 vertices and 511 edges
...
100000 samples taken, with per sample time taking 36.17 us
Total time spent 3 seconds
```
This compares to the python implementation down from ~1ms per sample to 36us per sample. But still limited to linear performance improvement.

### 1000 Vertices
```
Created graph with 1000 vertices and 49714 edges
...
1000 samples taken, with per sample time taking 1.05 ms
Total time spent 1 seconds
```

### 10000 Vertices
```
Created graph with 10000 vertices and 24974 edges
...
1000 samples taken, with per sample time taking 18.21 ms
Total time spent 18 seconds
```

### Complete Graph, 10000 Vertices
```
Created graph with 10000 vertices and 49995000 edges
...
1000 samples taken, with per sample time taking 919.95 ms
Total time spent 919 seconds

```

MTT matrix method could do this in 90 seconds.

### Ring Graph, 1000 Vertices
```
Created graph with 1000 vertices and 1000 edges
...
1000 samples taken, with per sample time taking 16.95 ms
Total time spent 16 seconds
```

### 3D Lattice Graph, ï½ž30000 Vertices
```
Created graph with 35937 vertices and 107811 edges
...
1000 samples taken, with per sample time taking 29.75 ms
Total time spent 29 seconds
```

Lattice seems to be friendlier to Markov Chains.